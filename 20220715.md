# leetcode刷题技巧

## 双指针

### 同方向

0 -> i -> j -> n

[0, i) processed, [i, j) not needed, [j, n) unkown

处理好的相对位置会保持一致。

[1, 2, 0, 3, 0, 8] move zeros to the end

通用解题步骤：

1. Initialize two pointers i and j, usually both equal 0

2. while j < array.length

    - if we need array[j], then we keep it by assigning array[i] = array[j], and move i forward, make it ready at the next position.

    - otherwise skip it. We do not need to move i since its spot it not fulfilled.

### 反方向

0 -> i j <- n

[0, i) processed, [i, j] unkown, [j, n) processed

其中[0, i)和(j, n)内的数据均为处理好的数据，[i, j]中的数据待处理。用此方法处理过的数组不会保留原来元素的相对位置。

通用解题步骤

1. Initialize two pointers i = 0, j = array.length - 1

2. while i <= j

    - Decide what you should do based on the value of array[i] and array[j]

    - Move at least one pointer to the next position

相关题目：【11】、【42】、【283】、【80】、【1047】

## Binary Search

1. 每次都要缩减搜索区域

Shrink the search space every iteration (or recusion)

2. 每次缩减不能排除潜在答案

Cannot exclude potential answers during each shrinking

三大通用模版

- 找一个准确值
    - 循环条件：l <= r
    - 缩减搜索空间：l = mid + 1, r = mid - 1

- 找一个模糊值（比4大的最小数）
    - 循环条件：l < r
    - 缩减搜索空间：l = mid, r = mid - 1 或者 l = mid + 1, r = mid

- 万用型
    - 循环条件：l < r - 1
    - 缩减搜索空间：l = mid, r = mid

相关题目：【410】、【1231】、【852】、【1011】、【1292】

## LinkedList

要点

1. 一个快一个慢，距离隔开多少

2. 两个指针移动速度

eg: 找中间节点

High Level Idea:

1. Initailize 2 pointer i and j pointing to the head

2. While the next move of the faster pointer j is valid(inside bound), move j two steps and i one step forward

3. Return the node at i

```ts
function linkedListMiddleNode(head) {
    let i = head, j = head;
    while (j !== null && j.next !== null) {
        i = head.next;
        j = head.next.next;
    }
    return i;
}
```

eg: 找倒数第k个节点

High Level Idea:

1. Initialize two pointers i and j pointing to the head

2. Move j k steps forward

3. Move both i and j one step forward at a time until j is out of bound

```ts
function linkedListLastKthNode(head) {
    let i = head, j = head;
    for (let c = 0; c < k; c++) {
        j = j.next;
    }
    while (j !== null) {
        i = i.next;
        j = j.next;
    }
    return i;
}
```

Recursion 递归

Bottom up recursion 3 steps: 

1. Ask for subproblem Resolution

2. Do something in current level of recursion

3. Return result

eg: Reverse Linked List

```ts
function reverseLinkedList(head) {
    if (head === null || head.next === null) {
        return head;
    }
    let newHead = reverseLinkedList(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

相关题目：【237】、【141】、【92】、【25】

## Stack 解题模板

- 特征：LIFO(Last In First Out)

- 适用于需要记录之前的状态，必要的时候可以回到之前的状态，或者利用之前的值

- 不像Array，不能用index访问，只能每次拿栈顶元素

题外话：Dynamic Programming

- DP: 记录之前所有状态，随时可能访问任何一个子问题，所有通常用Array或者HashTable，而且不会回到之前的状态，只会利用之前的值

- Stack: 每次只需要栈顶元素，并且每个状态只用被用O(1)次

Stack Principle

定义好Stack的含义

- 在arr[i]左侧所有比arr[i]大的数

- 递归之前的函数状态（Call Stack）

eg: Daily Temperatures

Stack Definition: All the elements(index) to the right of arr[i] that are greater than arr[i]

High Level Idea:

1. Initialize stack

2. For each element arr[i] backwards 
    a. pop until stack is empty or top of stack > arr[i]

3. Calculate distance from arr[i] to top of stack

4. Repeat

```ts
function dailyTemperatures(arr) {
    if (!arr || arr.length === 0) return [];
    const len = arr.length, stack = [], res = [];
    for (let i = len - 1; i >= 0; i--) {
        while (!stack.isEmpty() && arr[i] >= arr[stack.peek()]) {
            stack.pop();
        }
        if (stack.isEmpty()) {
            res[i] = 0;
        } else {
            res[i] = stack.peek() - i;
        }
        stack.push(i);
    }
    return res;
}

Array.prototype.peek = function() {
    return this[this.length - 1];
}

Array.prototype.isEmpty = function () {
    return this.length === 0;
}
```

eg: Asteriod Collision

Stack Definition: All asteriods left so far

Top of Stack: Closest survived asteriod to the left of arr[i]

High level Idea:

1. Initialize Stack

2. For each arr[i]

    - a. if arr[i] > 0, push to stack

    - b. else keep popping "smaller" until stack is empty or top element < 0

    - c. special dealing with "equal"

    - d. push arr[i] to stack if survived

3. Repeat

```ts
function asteroidCollision(asteroids) {
    const stack = [];
    for (let ast of asteroids) {
        if (ast > 0) {
            stack.push(ast);
        } else {
            while (!stack.isEmpty() && stack.peek() > 0 && stack.peek() + ast <= 0) {
                stack.pop();
            }
            if (stack.isEmpty() || stack.peek() < 0) {
                stack.push(ast);
            }
        }
    }
    return stack;
}

Array.prototype.peek = function() {
    return this[this.length - 1];
}

Array.prototype.isEmpty = function() {
    return this.length === 0;
}
```

相关题目：【20】、【496】、【503】、【394】、【636】、【84】