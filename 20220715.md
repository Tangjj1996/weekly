# leetcode刷题技巧

## 双指针

### 同方向

0 -> i -> j -> n

[0, i) processed, [i, j) not needed, [j, n) unkown

处理好的相对位置会保持一致。

[1, 2, 0, 3, 0, 8] move zeros to the end

通用解题步骤：

1. Initialize two pointers i and j, usually both equal 0

2. while j < array.length

    - if we need array[j], then we keep it by assigning array[i] = array[j], and move i forward, make it ready at the next position.

    - otherwise skip it. We do not need to move i since its spot it not fulfilled.

### 反方向

0 -> i j <- n

[0, i) processed, [i, j] unkown, [j, n) processed

其中[0, i)和(j, n)内的数据均为处理好的数据，[i, j]中的数据待处理。用此方法处理过的数组不会保留原来元素的相对位置。

通用解题步骤

1. Initialize two pointers i = 0, j = array.length - 1

2. while i <= j

    - Decide what you should do based on the value of array[i] and array[j]

    - Move at least one pointer to the next position

相关题目：【11】、【42】、【283】、【80】、【1047】

## Binary Search

1. 每次都要缩减搜索区域

Shrink the search space every iteration (or recusion)

2. 每次缩减不能排除潜在答案

Cannot exclude potential answers during each shrinking

三大通用模版

- 找一个准确值
    - 循环条件：l <= r
    - 缩减搜索空间：l = mid + 1, r = mid - 1

- 找一个模糊值（比4大的最小数）
    - 循环条件：l < r
    - 缩减搜索空间：l = mid, r = mid - 1 或者 l = mid + 1, r = mid

- 万用型
    - 循环条件：l < r - 1
    - 缩减搜索空间：l = mid, r = mid

相关题目：【410】、【1231】、【852】、【1011】、【1292】

## LinkedList

要点

1. 一个快一个慢，距离隔开多少

2. 两个指针移动速度

eg: 找中间节点

High Level Idea:

1. Initailize 2 pointer i and j pointing to the head

2. While the next move of the faster pointer j is valid(inside bound), move j two steps and i one step forward

3. Return the node at i

```ts
function linkedListMiddleNode(head) {
    let i = head, j = head;
    while (j !== null && j.next !== null) {
        i = head.next;
        j = head.next.next;
    }
    return i;
}
```

eg: 找倒数第k个节点

High Level Idea:

1. Initialize two pointers i and j pointing to the head

2. Move j k steps forward

3. Move both i and j one step forward at a time until j is out of bound

```ts
function linkedListLastKthNode(head) {
    let i = head, j = head;
    for (let c = 0; c < k; c++) {
        j = j.next;
    }
    while (j !== null) {
        i = i.next;
        j = j.next;
    }
    return i;
}
```

Recursion 递归

Bottom up recursion 3 steps: 

1. Ask for subproblem Resolution

2. Do something in current level of recursion

3. Return result

eg: Reverse Linked List

```ts
function reverseLinkedList(head) {
    if (head === null || head.next === null) {
        return head;
    }
    let newHead = reverseLinkedList(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

相关题目：【237】、【141】、【92】、【25】

## Stack 解题模板

- 特征：LIFO(Last In First Out)

- 适用于需要记录之前的状态，必要的时候可以回到之前的状态，或者利用之前的值

- 不像Array，不能用index访问，只能每次拿栈顶元素

题外话：Dynamic Programming

- DP: 记录之前所有状态，随时可能访问任何一个子问题，所有通常用Array或者HashTable，而且不会回到之前的状态，只会利用之前的值

- Stack: 每次只需要栈顶元素，并且每个状态只用被用O(1)次

Stack Principle

定义好Stack的含义

- 在arr[i]左侧所有比arr[i]大的数

- 递归之前的函数状态（Call Stack）

eg: Daily Temperatures

Stack Definition: All the elements(index) to the right of arr[i] that are greater than arr[i]

High Level Idea:

1. Initialize stack

2. For each element arr[i] backwards 
    a. pop until stack is empty or top of stack > arr[i]

3. Calculate distance from arr[i] to top of stack

4. Repeat

```ts
function dailyTemperatures(arr) {
    if (!arr || arr.length === 0) return [];
    const len = arr.length, stack = [], res = [];
    for (let i = len - 1; i >= 0; i--) {
        while (!stack.isEmpty() && arr[i] >= arr[stack.peek()]) {
            stack.pop();
        }
        if (stack.isEmpty()) {
            res[i] = 0;
        } else {
            res[i] = stack.peek() - i;
        }
        stack.push(i);
    }
    return res;
}

Array.prototype.peek = function() {
    return this[this.length - 1];
}

Array.prototype.isEmpty = function () {
    return this.length === 0;
}
```

eg: Asteriod Collision

Stack Definition: All asteriods left so far

Top of Stack: Closest survived asteriod to the left of arr[i]

High level Idea:

1. Initialize Stack

2. For each arr[i]

    - a. if arr[i] > 0, push to stack

    - b. else keep popping "smaller" until stack is empty or top element < 0

    - c. special dealing with "equal"

    - d. push arr[i] to stack if survived

3. Repeat

```ts
function asteroidCollision(asteroids) {
    const stack = [];
    for (let ast of asteroids) {
        if (ast > 0) {
            stack.push(ast);
        } else {
            while (!stack.isEmpty() && stack.peek() > 0 && stack.peek() + ast <= 0) {
                stack.pop();
            }
            if (stack.isEmpty() || stack.peek() < 0) {
                stack.push(ast);
            }
        }
    }
    return stack;
}

Array.prototype.peek = function() {
    return this[this.length - 1];
}

Array.prototype.isEmpty = function() {
    return this.length === 0;
}
```

相关题目：【20】、【496】、【503】、【394】、【636】、【84】

## Heap

eg: Kth Largest Element in an Array

- Sorting O(nlogn)
    - Sort the array and get the kth element

- Max Heap O(n + klogn)
    - Heapify the array, then poll k times

- Min Heap O(nlogk)
    - Maintain a size k min Heap

    - Add element to min heap if greater than or equal to the top element, adjust size if necessary
    
    - At the end top of heap is the kth largest

> since we are adding greater elements in the heap every time. At the end, the top of min heap is the smallest among elements in the heap, but it's greater than any other element in the array, which in other words: kth largest element in the array.

General Steps:

1. Initialize a min heap

2. For each element x in the array
    - a. Offer to heap if heap size < k or x >= top of heap

    - adjust heap size if necessary

3. Return the top of heap

> it's an online algorithm since each time the top of heap is the kth largest element, and it's scalable if the input is a stream

相关题目：【347】、【253】、【295】、【767】、【703】

## HashMap

eg: Subarray Sum Equals k

当需要快速查找数据时，可以利用HashMap加速查找

查找对象：all sum seen so far util current index -> # of times it occurs

当current sum - k 存在于map内，那么answer += map.get(sum - k)

因为sum - k存在于map内说明之前sum(0, x)出现了y次，那么：

subarray sum = current sum - sum(0, x) = k多出现了y次

要点：Map内一开始存在一个{0, 1}，代表sum = 0默认出现了1次

Solution Steps:

1. Initialize HashMap with {0, 1}

2. Initialize sum = 0, result = 0

3. For each number x in array
    - a. sum += x

    - b. if sum - k is in the map -> result += map.get(sum - k)

    - c. put sum into the map, icrease its count if exits

```ts
function subArraySum(nums, k) {
    const hashMap = new Map();
    let sum = 0, result = 0;
    hashMap.set(0, 1);
    for (let item of nums) {
        sum += item;
        if (hashMap.has(sum - k)) {
            result += hashMap.get(sum - k);
        }
        hashMap.set(sum, hashMap.has(sum) ? hashMap.get(sum) + 1 : 1);
    }
    return result;
}
```

## bfs(Breadth-First Search)

BFS（宽度优先搜索）是按“层”的概念进行的搜索算法，利用Queue记录需要被展开的TreeNode

BFS General Steps

1. Initialize Queue with all entry points

2. While queue is not empty
    - a. for each node in the queue(currently)

    - b. poll out the element(add to result)

    - c. expand it, offer children to the queue in order

    - d. increase level

```ts
function levelOrder(root) {
    const res = [];
    if (root === null) return res;
    const queue = [];
    queue.push(root);
    while (queue.length > 0) {
        let size = queue.length;
        const temp = []
        while (size--) {
            const curr = queue.shift();
            temp.push(curr.val);
            curr.left && queue.push(curr.left);
            curr.right && queue.push(curr.right);
        }
        res.push(temp);
    }
    return res;
}
```

eg: Maximum Depth of Binary Tree

```ts
function maxDepth(root) {
    if (root === null) return 0;
    let depth = 0;
    const queue = [];
    queue.push(root);
    while (queue.length > 0) {
        let size = queue.size;
        while (size--) {
            const curr = queue.shift();
            curr.left && queue.push(curr.left);
            curr.right && queue.push(curr.right);
        }
        depth++;
    }
}
```

eg: Binary Tree Right Side View

```ts
function rightSideView(root) {
    if (root === null) return null;
    const queue = [], res = [];
    queue.push(root);
    while (queue.length > 0) {
        let size = queue.size();
        res.push(queue[size - 1].val);
        while (size--) {
            const curr = queue.shift();
            curr.left && queue.push(curr.left);
            curr.right && queue.push(curr.right);
        }
    }
    return res;
}
```

## dfs

bottom up dfs

General Steps:

1. Base Case

2. 向子问题要答案（return value）

3. 利用子问题的答案构建当前问题（当前递归层）的答案

4. 若有必要，做一些额外操作

5. 返回答案（给父问题）

top down dfs

General Steps:

1. Base Case

2. 利用父问题传下来的值做一些计算

3. 若有必要，做一些额外操作

4. 把值传下去给子问题继续递归

相关题目：【98】、【110】、【113】、【236】、【450】、【508】