# leetcode刷题技巧

## 双指针

### 同方向

0 -> i -> j -> n

[0, i) processed, [i, j) not needed, [j, n) unkown

处理好的相对位置会保持一致。

[1, 2, 0, 3, 0, 8] move zeros to the end

通用解题步骤：

1. Initialize two pointers i and j, usually both equal 0

2. while j < array.length

    - if we need array[j], then we keep it by assigning array[i] = array[j], and move i forward, make it ready at the next position.

    - otherwise skip it. We do not need to move i since its spot it not fulfilled.

### 反方向

0 -> i j <- n

[0, i) processed, [i, j] unkown, [j, n) processed

其中[0, i)和(j, n)内的数据均为处理好的数据，[i, j]中的数据待处理。用此方法处理过的数组不会保留原来元素的相对位置。

通用解题步骤

1. Initialize two pointers i = 0, j = array.length - 1

2. while i <= j

    - Decide what you should do based on the value of array[i] and array[j]

    - Move at least one pointer to the next position

相关题目：【11】、【42】、【283】、【80】、【1047】

## Binary Search

1. 每次都要缩减搜索区域

Shrink the search space every iteration (or recusion)

2. 每次缩减不能排除潜在答案

Cannot exclude potential answers during each shrinking

三大通用模版

- 找一个准确值
    - 循环条件：l <= r
    - 缩减搜索空间：l = mid + 1, r = mid - 1

- 找一个模糊值（比4大的最小数）
    - 循环条件：l < r
    - 缩减搜索空间：l = mid, r = mid - 1 或者 l = mid + 1, r = mid

- 万用型
    - 循环条件：l < r - 1
    - 缩减搜索空间：l = mid, r = mid

相关题目：【410】、【1231】、【852】、【1011】、【1292】